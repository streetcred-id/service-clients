# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Credentials
  #
  # A service client - single point of access to the REST API.
  #
  class CredentialsClient < MsRest::ServiceClient
    include MsRest::Serialization

    # @return [String] the base URI of the service.
    attr_accessor :base_url

    # @return Subscription credentials which uniquely identify client
    # subscription.
    attr_accessor :credentials

    #
    # Creates initializes a new instance of the CredentialsClient class.
    # @param credentials [MsRest::ServiceClientCredentials] credentials to authorize HTTP requests made by the service client.
    # @param base_url [String] the base URI of the service.
    # @param options [Array] filters to be applied to the HTTP requests.
    #
    def initialize(credentials = nil, base_url = nil, options = nil)
      super(credentials, options)
      @base_url = base_url || 'https://api.trinsic.id/credentials/v1'

      fail ArgumentError, 'invalid type of credentials input parameter' unless credentials.is_a?(MsRest::ServiceClientCredentials) unless credentials.nil?
      @credentials = credentials

      add_telemetry
    end

    #
    # Makes a request and returns the body of the response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Hash{String=>String}] containing the body of the response.
    # Example:
    #
    #  request_content = "{'location':'westus','tags':{'tag1':'val1','tag2':'val2'}}"
    #  path = "/path"
    #  options = {
    #    body: request_content,
    #    query_params: {'api-version' => '2016-02-01'}
    #  }
    #  result = @client.make_request(:put, path, options)
    #
    def make_request(method, path, options = {})
      result = make_request_with_http_info(method, path, options)
      result.body unless result.nil?
    end

    #
    # Makes a request and returns the operation response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [MsRest::HttpOperationResponse] Operation response containing the request, response and status.
    #
    def make_request_with_http_info(method, path, options = {})
      result = make_request_async(method, path, options).value!
      result.body = result.response.body.to_s.empty? ? nil : JSON.load(result.response.body)
      result
    end

    #
    # Makes a request asynchronously.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def make_request_async(method, path, options = {})
      fail ArgumentError, 'method is nil' if method.nil?
      fail ArgumentError, 'path is nil' if path.nil?

      request_url = options[:base_url] || @base_url
      if(!options[:headers].nil? && !options[:headers]['Content-Type'].nil?)
        @request_headers['Content-Type'] = options[:headers]['Content-Type']
      end

      request_headers = @request_headers
      options.merge!({headers: request_headers.merge(options[:headers] || {})})
      options.merge!({credentials: @credentials}) unless @credentials.nil?

      super(request_url, method, path, options)
    end

    #
    # [Deprecated] Upload image
    #
    # Please use the Provider API instead.
    # Upload an image and return a URL with the static remote location.
    #
    # @param uploaded_files The uploaded files
    # @param filename [String] The filename
    # @param content_type [String] Type of the image content
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [String] operation results.
    #
    def upload_image(uploaded_files, filename:nil, content_type:nil, custom_headers:nil)
      response = upload_image_async(uploaded_files, filename:filename, content_type:content_type, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] Upload image
    #
    # Please use the Provider API instead.
    # Upload an image and return a URL with the static remote location.
    #
    # @param uploaded_files The uploaded files
    # @param filename [String] The filename
    # @param content_type [String] Type of the image content
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def upload_image_with_http_info(uploaded_files, filename:nil, content_type:nil, custom_headers:nil)
      upload_image_async(uploaded_files, filename:filename, content_type:content_type, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Upload image
    #
    # Please use the Provider API instead.
    # Upload an image and return a URL with the static remote location.
    #
    # @param uploaded_files The uploaded files
    # @param filename [String] The filename
    # @param content_type [String] Type of the image content
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def upload_image_async(uploaded_files, filename:nil, content_type:nil, custom_headers:nil)
      fail ArgumentError, 'uploaded_files is nil' if uploaded_files.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'multipart/form-data'

      # Set Form Data
      form_data = {}
      form_data['uploadedFiles'] = uploaded_files.to_s unless uploaded_files.to_s.nil?
      form_data['filename'] = filename unless filename.nil?
      form_data['contentType'] = content_type unless content_type.nil?

      path_template = 'common/upload'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          body: URI.encode_www_form(form_data),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'String'
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] List all ledger networks
    #
    # Please use the Provider API instead.
    # List all available ledger networks.
    # Some networks are not available based on your subscription.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_networks(custom_headers:nil)
      response = list_networks_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] List all ledger networks
    #
    # Please use the Provider API instead.
    # List all available ledger networks.
    # Some networks are not available based on your subscription.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_networks_with_http_info(custom_headers:nil)
      list_networks_async(custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] List all ledger networks
    #
    # Please use the Provider API instead.
    # List all available ledger networks.
    # Some networks are not available based on your subscription.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_networks_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'common/networks'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'NetworkContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'NetworkContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] Get network transaction author agreement
    #
    # This endpoint is no longer needed.
    # Get the latest transaction author agreement and acceptance methods if one is
    # set on the specified network.
    #
    # @param network_id [String] The network identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [NetworkTxnAgreementContract] operation results.
    #
    def get_transaction_author_agreement(network_id, custom_headers:nil)
      response = get_transaction_author_agreement_async(network_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] Get network transaction author agreement
    #
    # This endpoint is no longer needed.
    # Get the latest transaction author agreement and acceptance methods if one is
    # set on the specified network.
    #
    # @param network_id [String] The network identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_transaction_author_agreement_with_http_info(network_id, custom_headers:nil)
      get_transaction_author_agreement_async(network_id, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Get network transaction author agreement
    #
    # This endpoint is no longer needed.
    # Get the latest transaction author agreement and acceptance methods if one is
    # set on the specified network.
    #
    # @param network_id [String] The network identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_transaction_author_agreement_async(network_id, custom_headers:nil)
      fail ArgumentError, 'network_id is nil' if network_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'common/networks/{networkId}/txnAuthorAgreement'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'networkId' => network_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::NetworkTxnAgreementContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] Accept network transaction author agreement
    #
    # This endpoint is no longer needed.
    # Accept the latest transaction author agreement on the specified network.
    #
    # @param tenant_id [String] The tenant identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def accept_transaction_author_agreement(tenant_id, custom_headers:nil)
      response = accept_transaction_author_agreement_async(tenant_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # [Deprecated] Accept network transaction author agreement
    #
    # This endpoint is no longer needed.
    # Accept the latest transaction author agreement on the specified network.
    #
    # @param tenant_id [String] The tenant identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def accept_transaction_author_agreement_with_http_info(tenant_id, custom_headers:nil)
      accept_transaction_author_agreement_async(tenant_id, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Accept network transaction author agreement
    #
    # This endpoint is no longer needed.
    # Accept the latest transaction author agreement on the specified network.
    #
    # @param tenant_id [String] The tenant identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def accept_transaction_author_agreement_async(tenant_id, custom_headers:nil)
      fail ArgumentError, 'tenant_id is nil' if tenant_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'common/networks/{tenantId}/txnAuthorAgreement'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'tenantId' => tenant_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # List all connections
    #
    # Retrieve a list of all connections.
    # Optionally, list only connections in a specified state.
    #
    # @param state [Enum] The connection state. Possible values include: 'Invited',
    # 'Negotiating', 'Connected'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_connections(state:nil, custom_headers:nil)
      response = list_connections_async(state:state, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all connections
    #
    # Retrieve a list of all connections.
    # Optionally, list only connections in a specified state.
    #
    # @param state [Enum] The connection state. Possible values include: 'Invited',
    # 'Negotiating', 'Connected'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_connections_with_http_info(state:nil, custom_headers:nil)
      list_connections_async(state:state, custom_headers:custom_headers).value!
    end

    #
    # List all connections
    #
    # Retrieve a list of all connections.
    # Optionally, list only connections in a specified state.
    #
    # @param state [Enum] The connection state. Possible values include: 'Invited',
    # 'Negotiating', 'Connected'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_connections_async(state:nil, custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'connections'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'state' => state},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'ConnectionContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'ConnectionContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create connection
    #
    # Initiate a new connection by creating an invitation.
    # The newly created connection record will be in state 'Invited' until the
    # other party has accepted the invitation.
    # The response body includes details about the newly creation connection.
    #
    # @param body [ConnectionInvitationParameters] Connection invitation parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ConnectionContract] operation results.
    #
    def create_connection(body, custom_headers:nil)
      response = create_connection_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create connection
    #
    # Initiate a new connection by creating an invitation.
    # The newly created connection record will be in state 'Invited' until the
    # other party has accepted the invitation.
    # The response body includes details about the newly creation connection.
    #
    # @param body [ConnectionInvitationParameters] Connection invitation parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_connection_with_http_info(body, custom_headers:nil)
      create_connection_async(body, custom_headers:custom_headers).value!
    end

    #
    # Create connection
    #
    # Initiate a new connection by creating an invitation.
    # The newly created connection record will be in state 'Invited' until the
    # other party has accepted the invitation.
    # The response body includes details about the newly creation connection.
    #
    # @param body [ConnectionInvitationParameters] Connection invitation parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_connection_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::ConnectionInvitationParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'connections'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::ConnectionContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get connection
    #
    # Get the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ConnectionContract] operation results.
    #
    def get_connection(connection_id, custom_headers:nil)
      response = get_connection_async(connection_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get connection
    #
    # Get the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_connection_with_http_info(connection_id, custom_headers:nil)
      get_connection_async(connection_id, custom_headers:custom_headers).value!
    end

    #
    # Get connection
    #
    # Get the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_connection_async(connection_id, custom_headers:nil)
      fail ArgumentError, 'connection_id is nil' if connection_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'connections/{connectionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'connectionId' => connection_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::ConnectionContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Delete connection
    #
    # Delete the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_connection(connection_id, custom_headers:nil)
      response = delete_connection_async(connection_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete connection
    #
    # Delete the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_connection_with_http_info(connection_id, custom_headers:nil)
      delete_connection_async(connection_id, custom_headers:custom_headers).value!
    end

    #
    # Delete connection
    #
    # Delete the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_connection_async(connection_id, custom_headers:nil)
      fail ArgumentError, 'connection_id is nil' if connection_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'connections/{connectionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'connectionId' => connection_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # List all credentials
    #
    # List all credentials that match any specified query parameters.
    # No query parameters are required, but any provided will filter the results.
    #
    # @param connection_id [String] A connection identifier
    # @param state [Enum] The state of credentials. Possible values include:
    # 'Offered', 'Requested', 'Issued', 'Rejected', 'Revoked'
    # @param definition_id [String] A credential definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_credentials(connection_id:nil, state:nil, definition_id:nil, custom_headers:nil)
      response = list_credentials_async(connection_id:connection_id, state:state, definition_id:definition_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all credentials
    #
    # List all credentials that match any specified query parameters.
    # No query parameters are required, but any provided will filter the results.
    #
    # @param connection_id [String] A connection identifier
    # @param state [Enum] The state of credentials. Possible values include:
    # 'Offered', 'Requested', 'Issued', 'Rejected', 'Revoked'
    # @param definition_id [String] A credential definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_credentials_with_http_info(connection_id:nil, state:nil, definition_id:nil, custom_headers:nil)
      list_credentials_async(connection_id:connection_id, state:state, definition_id:definition_id, custom_headers:custom_headers).value!
    end

    #
    # List all credentials
    #
    # List all credentials that match any specified query parameters.
    # No query parameters are required, but any provided will filter the results.
    #
    # @param connection_id [String] A connection identifier
    # @param state [Enum] The state of credentials. Possible values include:
    # 'Offered', 'Requested', 'Issued', 'Rejected', 'Revoked'
    # @param definition_id [String] A credential definition identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_credentials_async(connection_id:nil, state:nil, definition_id:nil, custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'credentials'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'connectionId' => connection_id,'state' => state,'definitionId' => definition_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'CredentialContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'CredentialContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create and offer credential
    #
    # Send a credential offer of the specified credential definition to the
    # specified connection.
    #
    # @param body [CredentialOfferParameters] The definition and connection to
    # which this offer will be sent
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CredentialContract] operation results.
    #
    def create_credential(body, custom_headers:nil)
      response = create_credential_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create and offer credential
    #
    # Send a credential offer of the specified credential definition to the
    # specified connection.
    #
    # @param body [CredentialOfferParameters] The definition and connection to
    # which this offer will be sent
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_credential_with_http_info(body, custom_headers:nil)
      create_credential_async(body, custom_headers:custom_headers).value!
    end

    #
    # Create and offer credential
    #
    # Send a credential offer of the specified credential definition to the
    # specified connection.
    #
    # @param body [CredentialOfferParameters] The definition and connection to
    # which this offer will be sent
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_credential_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::CredentialOfferParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'credentials'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::CredentialContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get credential
    #
    # Get the specified credential.
    #
    # @param credential_id [String] The credential identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CredentialContract] operation results.
    #
    def get_credential(credential_id, custom_headers:nil)
      response = get_credential_async(credential_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get credential
    #
    # Get the specified credential.
    #
    # @param credential_id [String] The credential identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_credential_with_http_info(credential_id, custom_headers:nil)
      get_credential_async(credential_id, custom_headers:custom_headers).value!
    end

    #
    # Get credential
    #
    # Get the specified credential.
    #
    # @param credential_id [String] The credential identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_credential_async(credential_id, custom_headers:nil)
      fail ArgumentError, 'credential_id is nil' if credential_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'credentials/{credentialId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'credentialId' => credential_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::CredentialContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Issue credential
    #
    # Issue the specified credential.
    # If the values offered were incorrect, changes to the values may be made here.
    # You must update all of the values, and they must be follow the same structure
    # of the schema.
    # To keep the values the same as those included in the credential offer, leave
    # the body blank.
    #
    # @param credential_id [String] The credential identifier
    # @param body [Hash{String => String}] Updated credential values
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def issue_credential(credential_id, body:nil, custom_headers:nil)
      response = issue_credential_async(credential_id, body:body, custom_headers:custom_headers).value!
      nil
    end

    #
    # Issue credential
    #
    # Issue the specified credential.
    # If the values offered were incorrect, changes to the values may be made here.
    # You must update all of the values, and they must be follow the same structure
    # of the schema.
    # To keep the values the same as those included in the credential offer, leave
    # the body blank.
    #
    # @param credential_id [String] The credential identifier
    # @param body [Hash{String => String}] Updated credential values
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def issue_credential_with_http_info(credential_id, body:nil, custom_headers:nil)
      issue_credential_async(credential_id, body:body, custom_headers:custom_headers).value!
    end

    #
    # Issue credential
    #
    # Issue the specified credential.
    # If the values offered were incorrect, changes to the values may be made here.
    # You must update all of the values, and they must be follow the same structure
    # of the schema.
    # To keep the values the same as those included in the credential offer, leave
    # the body blank.
    #
    # @param credential_id [String] The credential identifier
    # @param body [Hash{String => String}] Updated credential values
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def issue_credential_async(credential_id, body:nil, custom_headers:nil)
      fail ArgumentError, 'credential_id is nil' if credential_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        client_side_validation: true,
        required: false,
        serialized_name: 'body',
        type: {
          name: 'Dictionary',
          value: {
              client_side_validation: true,
              required: false,
              serialized_name: 'StringElementType',
              type: {
                name: 'String'
              }
          }
        }
      }
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'credentials/{credentialId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'credentialId' => credential_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Revoke an issued credential
    #
    # Revoke credential that was issued previously.
    # Process of revocation will update the revocation registry locally and on the
    # ledger.
    # Issued credentials can still participate in proof workflows and be considered
    # valid, but only if the verifying ignores the revocation trail.
    #
    # @param credential_id [String] The credential identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def revoke_credential(credential_id, custom_headers:nil)
      response = revoke_credential_async(credential_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Revoke an issued credential
    #
    # Revoke credential that was issued previously.
    # Process of revocation will update the revocation registry locally and on the
    # ledger.
    # Issued credentials can still participate in proof workflows and be considered
    # valid, but only if the verifying ignores the revocation trail.
    #
    # @param credential_id [String] The credential identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def revoke_credential_with_http_info(credential_id, custom_headers:nil)
      revoke_credential_async(credential_id, custom_headers:custom_headers).value!
    end

    #
    # Revoke an issued credential
    #
    # Revoke credential that was issued previously.
    # Process of revocation will update the revocation registry locally and on the
    # ledger.
    # Issued credentials can still participate in proof workflows and be considered
    # valid, but only if the verifying ignores the revocation trail.
    #
    # @param credential_id [String] The credential identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def revoke_credential_async(credential_id, custom_headers:nil)
      fail ArgumentError, 'credential_id is nil' if credential_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'credentials/{credentialId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'credentialId' => credential_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Delete credential
    #
    # Delete the specified credential.
    # This endpoint does not revoke the credential.
    #
    # @param credential_id [String] The credential identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_credential(credential_id, custom_headers:nil)
      response = delete_credential_async(credential_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete credential
    #
    # Delete the specified credential.
    # This endpoint does not revoke the credential.
    #
    # @param credential_id [String] The credential identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_credential_with_http_info(credential_id, custom_headers:nil)
      delete_credential_async(credential_id, custom_headers:custom_headers).value!
    end

    #
    # Delete credential
    #
    # Delete the specified credential.
    # This endpoint does not revoke the credential.
    #
    # @param credential_id [String] The credential identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_credential_async(credential_id, custom_headers:nil)
      fail ArgumentError, 'credential_id is nil' if credential_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'credentials/delete/{credentialId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'credentialId' => credential_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # List all verification policies
    #
    # List all verification policies for the authenticated organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_verification_policies(custom_headers:nil)
      response = list_verification_policies_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all verification policies
    #
    # List all verification policies for the authenticated organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_verification_policies_with_http_info(custom_headers:nil)
      list_verification_policies_async(custom_headers:custom_headers).value!
    end

    #
    # List all verification policies
    #
    # List all verification policies for the authenticated organization.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_verification_policies_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verificationPolicies'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'VerificationPolicyContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'VerificationPolicyContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create verification policy
    #
    # Create a verification policy from the specified parameters.
    #
    # @param body [VerificationPolicyParameters] The verification policy parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationPolicyContract] operation results.
    #
    def create_verification_policy(body, custom_headers:nil)
      response = create_verification_policy_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create verification policy
    #
    # Create a verification policy from the specified parameters.
    #
    # @param body [VerificationPolicyParameters] The verification policy parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_verification_policy_with_http_info(body, custom_headers:nil)
      create_verification_policy_async(body, custom_headers:custom_headers).value!
    end

    #
    # Create verification policy
    #
    # Create a verification policy from the specified parameters.
    #
    # @param body [VerificationPolicyParameters] The verification policy parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_verification_policy_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::VerificationPolicyParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'verificationPolicies'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationPolicyContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get verification policy
    #
    # Get the specified verification policy.
    #
    # @param policy_id [String] The verification policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationPolicyContract] operation results.
    #
    def get_verification_policy(policy_id, custom_headers:nil)
      response = get_verification_policy_async(policy_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get verification policy
    #
    # Get the specified verification policy.
    #
    # @param policy_id [String] The verification policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_verification_policy_with_http_info(policy_id, custom_headers:nil)
      get_verification_policy_async(policy_id, custom_headers:custom_headers).value!
    end

    #
    # Get verification policy
    #
    # Get the specified verification policy.
    #
    # @param policy_id [String] The verification policy identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_verification_policy_async(policy_id, custom_headers:nil)
      fail ArgumentError, 'policy_id is nil' if policy_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verificationPolicies/{policyId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'policyId' => policy_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationPolicyContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Delete verification policy
    #
    # Delete the specified verification policy.
    #
    # @param policy_id [String] The verification policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_verification_policy(policy_id, custom_headers:nil)
      response = delete_verification_policy_async(policy_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete verification policy
    #
    # Delete the specified verification policy.
    #
    # @param policy_id [String] The verification policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_verification_policy_with_http_info(policy_id, custom_headers:nil)
      delete_verification_policy_async(policy_id, custom_headers:custom_headers).value!
    end

    #
    # Delete verification policy
    #
    # Delete the specified verification policy.
    #
    # @param policy_id [String] The verification policy identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_verification_policy_async(policy_id, custom_headers:nil)
      fail ArgumentError, 'policy_id is nil' if policy_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verificationPolicies/{policyId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'policyId' => policy_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # List all credential definitions
    #
    # List all credential definitions for the authorization context.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_credential_definitions(custom_headers:nil)
      response = list_credential_definitions_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all credential definitions
    #
    # List all credential definitions for the authorization context.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_credential_definitions_with_http_info(custom_headers:nil)
      list_credential_definitions_async(custom_headers:custom_headers).value!
    end

    #
    # List all credential definitions
    #
    # List all credential definitions for the authorization context.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_credential_definitions_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'definitions/credentials'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'CredentialDefinitionContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'CredentialDefinitionContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create credential definition and schema from parameters
    #
    # A credential definition is created and saved on your cloud agent.
    #
    # @param body [CredentialDefinitionFromSchemaParameters] Definition parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CredentialDefinitionContract] operation results.
    #
    def create_credential_definition(body, custom_headers:nil)
      response = create_credential_definition_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create credential definition and schema from parameters
    #
    # A credential definition is created and saved on your cloud agent.
    #
    # @param body [CredentialDefinitionFromSchemaParameters] Definition parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_credential_definition_with_http_info(body, custom_headers:nil)
      create_credential_definition_async(body, custom_headers:custom_headers).value!
    end

    #
    # Create credential definition and schema from parameters
    #
    # A credential definition is created and saved on your cloud agent.
    #
    # @param body [CredentialDefinitionFromSchemaParameters] Definition parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_credential_definition_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::CredentialDefinitionFromSchemaParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'definitions/credentials'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::CredentialDefinitionContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get credential definition
    #
    # Get the specified credential definition.
    #
    # @param definition_id [String] The credential definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CredentialDefinitionContract] operation results.
    #
    def get_credential_definition(definition_id, custom_headers:nil)
      response = get_credential_definition_async(definition_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get credential definition
    #
    # Get the specified credential definition.
    #
    # @param definition_id [String] The credential definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_credential_definition_with_http_info(definition_id, custom_headers:nil)
      get_credential_definition_async(definition_id, custom_headers:custom_headers).value!
    end

    #
    # Get credential definition
    #
    # Get the specified credential definition.
    #
    # @param definition_id [String] The credential definition identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_credential_definition_async(definition_id, custom_headers:nil)
      fail ArgumentError, 'definition_id is nil' if definition_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'definitions/credentials/{definitionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'definitionId' => definition_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::CredentialDefinitionContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create credential definition from schema
    #
    # Create a credential definition from the specified schema.
    #
    # @param schema_id [String] The schema identifier
    # @param body [CredentialDefinitionParameters] The definition parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CredentialDefinitionContract] operation results.
    #
    def create_credential_definition_for_schema_id(schema_id, body, custom_headers:nil)
      response = create_credential_definition_for_schema_id_async(schema_id, body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create credential definition from schema
    #
    # Create a credential definition from the specified schema.
    #
    # @param schema_id [String] The schema identifier
    # @param body [CredentialDefinitionParameters] The definition parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_credential_definition_for_schema_id_with_http_info(schema_id, body, custom_headers:nil)
      create_credential_definition_for_schema_id_async(schema_id, body, custom_headers:custom_headers).value!
    end

    #
    # Create credential definition from schema
    #
    # Create a credential definition from the specified schema.
    #
    # @param schema_id [String] The schema identifier
    # @param body [CredentialDefinitionParameters] The definition parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_credential_definition_for_schema_id_async(schema_id, body, custom_headers:nil)
      fail ArgumentError, 'schema_id is nil' if schema_id.nil?
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::CredentialDefinitionParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'definitions/credentials/{schemaId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'schemaId' => schema_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::CredentialDefinitionContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Delete credential definition
    #
    # Delete the specified credential definition.
    #
    # @param credential_definition_id [String] The credential definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_credential_definition(credential_definition_id, custom_headers:nil)
      response = delete_credential_definition_async(credential_definition_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete credential definition
    #
    # Delete the specified credential definition.
    #
    # @param credential_definition_id [String] The credential definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_credential_definition_with_http_info(credential_definition_id, custom_headers:nil)
      delete_credential_definition_async(credential_definition_id, custom_headers:custom_headers).value!
    end

    #
    # Delete credential definition
    #
    # Delete the specified credential definition.
    #
    # @param credential_definition_id [String] The credential definition identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_credential_definition_async(credential_definition_id, custom_headers:nil)
      fail ArgumentError, 'credential_definition_id is nil' if credential_definition_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'definitions/credentials/{credentialDefinitionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'credentialDefinitionId' => credential_definition_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Create schema
    #
    # Register schema with the current agency tenant and write the schema to the
    # ledger using the tenant as issuer.
    # This does not create credential definition.
    #
    # @param body [SchemaParameters] Schema parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [String] operation results.
    #
    def create_schema(body, custom_headers:nil)
      response = create_schema_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create schema
    #
    # Register schema with the current agency tenant and write the schema to the
    # ledger using the tenant as issuer.
    # This does not create credential definition.
    #
    # @param body [SchemaParameters] Schema parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_schema_with_http_info(body, custom_headers:nil)
      create_schema_async(body, custom_headers:custom_headers).value!
    end

    #
    # Create schema
    #
    # Register schema with the current agency tenant and write the schema to the
    # ledger using the tenant as issuer.
    # This does not create credential definition.
    #
    # @param body [SchemaParameters] Schema parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_schema_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::SchemaParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'definitions/schemas'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'String'
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List all schemas
    #
    # List all schemas registered to or used by the authenticated organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_schemas(custom_headers:nil)
      response = list_schemas_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all schemas
    #
    # List all schemas registered to or used by the authenticated organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_schemas_with_http_info(custom_headers:nil)
      list_schemas_async(custom_headers:custom_headers).value!
    end

    #
    # List all schemas
    #
    # List all schemas registered to or used by the authenticated organization.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_schemas_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'definitions/schemas'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'SchemaRecordElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'SchemaRecord'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] Get verification definition
    #
    # Please use Verification Policies endpoints.
    # Get the specified verification definition.
    #
    # @param definition_id [String] The verification definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationDefinitionContract] operation results.
    #
    def get_verification_definition(definition_id, custom_headers:nil)
      response = get_verification_definition_async(definition_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] Get verification definition
    #
    # Please use Verification Policies endpoints.
    # Get the specified verification definition.
    #
    # @param definition_id [String] The verification definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_verification_definition_with_http_info(definition_id, custom_headers:nil)
      get_verification_definition_async(definition_id, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Get verification definition
    #
    # Please use Verification Policies endpoints.
    # Get the specified verification definition.
    #
    # @param definition_id [String] The verification definition identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_verification_definition_async(definition_id, custom_headers:nil)
      fail ArgumentError, 'definition_id is nil' if definition_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'definitions/verifications/{definitionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'definitionId' => definition_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationDefinitionContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] List all verification definitions
    #
    # Please use Verification Policies endpoints.
    # List all verification definitions for the authenticated organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_verification_definitions(custom_headers:nil)
      response = list_verification_definitions_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] List all verification definitions
    #
    # Please use Verification Policies endpoints.
    # List all verification definitions for the authenticated organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_verification_definitions_with_http_info(custom_headers:nil)
      list_verification_definitions_async(custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] List all verification definitions
    #
    # Please use Verification Policies endpoints.
    # List all verification definitions for the authenticated organization.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_verification_definitions_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'definitions/verifications'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'VerificationDefinitionContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'VerificationDefinitionContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] Create verification definition
    #
    # Please use Verification Policies endpoints.
    # A verification definition is created and saved on your cloud agent.
    # You can discover your definition based on the ID that is returned or the
    # name.
    #
    # @param body [ProofRequest] The proof request
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationDefinitionContract] operation results.
    #
    def create_verification_definition(body, custom_headers:nil)
      response = create_verification_definition_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] Create verification definition
    #
    # Please use Verification Policies endpoints.
    # A verification definition is created and saved on your cloud agent.
    # You can discover your definition based on the ID that is returned or the
    # name.
    #
    # @param body [ProofRequest] The proof request
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_verification_definition_with_http_info(body, custom_headers:nil)
      create_verification_definition_async(body, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Create verification definition
    #
    # Please use Verification Policies endpoints.
    # A verification definition is created and saved on your cloud agent.
    # You can discover your definition based on the ID that is returned or the
    # name.
    #
    # @param body [ProofRequest] The proof request
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_verification_definition_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::ProofRequest.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'definitions/verifications'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationDefinitionContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] Delete verification definition
    #
    # Please use Verification Policies endpoints.
    # Delete the specified verification definition.
    #
    # @param verification_definition_id [String] The verification definition
    # identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_verification_definition(verification_definition_id, custom_headers:nil)
      response = delete_verification_definition_async(verification_definition_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # [Deprecated] Delete verification definition
    #
    # Please use Verification Policies endpoints.
    # Delete the specified verification definition.
    #
    # @param verification_definition_id [String] The verification definition
    # identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_verification_definition_with_http_info(verification_definition_id, custom_headers:nil)
      delete_verification_definition_async(verification_definition_id, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Delete verification definition
    #
    # Please use Verification Policies endpoints.
    # Delete the specified verification definition.
    #
    # @param verification_definition_id [String] The verification definition
    # identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_verification_definition_async(verification_definition_id, custom_headers:nil)
      fail ArgumentError, 'verification_definition_id is nil' if verification_definition_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'definitions/verifications/{verificationDefinitionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'verificationDefinitionId' => verification_definition_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Send message
    #
    # Send a message from the specified message parameters.
    #
    # @param body [BasicMessageParameters] The message parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def send_message(body, custom_headers:nil)
      response = send_message_async(body, custom_headers:custom_headers).value!
      nil
    end

    #
    # Send message
    #
    # Send a message from the specified message parameters.
    #
    # @param body [BasicMessageParameters] The message parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def send_message_with_http_info(body, custom_headers:nil)
      send_message_async(body, custom_headers:custom_headers).value!
    end

    #
    # Send message
    #
    # Send a message from the specified message parameters.
    #
    # @param body [BasicMessageParameters] The message parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def send_message_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::BasicMessageParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'messages'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # List all messages for connection
    #
    # List all messages for the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_messages(connection_id, custom_headers:nil)
      response = list_messages_async(connection_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all messages for connection
    #
    # List all messages for the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_messages_with_http_info(connection_id, custom_headers:nil)
      list_messages_async(connection_id, custom_headers:custom_headers).value!
    end

    #
    # List all messages for connection
    #
    # List all messages for the specified connection.
    #
    # @param connection_id [String] The connection identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_messages_async(connection_id, custom_headers:nil)
      fail ArgumentError, 'connection_id is nil' if connection_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'messages/connection/{connectionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'connectionId' => connection_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'BasicMessageRecordElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'BasicMessageRecord'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get message
    #
    # Get the details for the specified message.
    #
    # @param message_id [String] The message identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [BasicMessageContract] operation results.
    #
    def get_message(message_id, custom_headers:nil)
      response = get_message_async(message_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get message
    #
    # Get the details for the specified message.
    #
    # @param message_id [String] The message identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_message_with_http_info(message_id, custom_headers:nil)
      get_message_async(message_id, custom_headers:custom_headers).value!
    end

    #
    # Get message
    #
    # Get the details for the specified message.
    #
    # @param message_id [String] The message identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_message_async(message_id, custom_headers:nil)
      fail ArgumentError, 'message_id is nil' if message_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'messages/{messageId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'messageId' => message_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::BasicMessageContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] List all tenants
    #
    # Please use the Provider API instead.
    # List all tenants for the current authorization context.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_tenants(custom_headers:nil)
      response = list_tenants_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] List all tenants
    #
    # Please use the Provider API instead.
    # List all tenants for the current authorization context.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_tenants_with_http_info(custom_headers:nil)
      list_tenants_async(custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] List all tenants
    #
    # Please use the Provider API instead.
    # List all tenants for the current authorization context.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_tenants_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'tenants'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'TenantContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'TenantContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] Create tenant
    #
    # Please use the Provider API instead.
    # Create a new tenant and setup a unique agency endpoint.
    # The agency will be set as an issuer.
    #
    # @param body [TenantParameters] Configuration options for creating new tenant
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TenantContract] operation results.
    #
    def create_tenant(body, custom_headers:nil)
      response = create_tenant_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] Create tenant
    #
    # Please use the Provider API instead.
    # Create a new tenant and setup a unique agency endpoint.
    # The agency will be set as an issuer.
    #
    # @param body [TenantParameters] Configuration options for creating new tenant
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_tenant_with_http_info(body, custom_headers:nil)
      create_tenant_async(body, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Create tenant
    #
    # Please use the Provider API instead.
    # Create a new tenant and setup a unique agency endpoint.
    # The agency will be set as an issuer.
    #
    # @param body [TenantParameters] Configuration options for creating new tenant
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_tenant_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::TenantParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'tenants'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::TenantContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprectaed] Get tenant
    #
    # Please use the Provider API instead.
    # Get the configuration for the specified tenant.
    #
    # @param tenant_id [String] The tenant identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TenantContract] operation results.
    #
    def get_tenant(tenant_id, custom_headers:nil)
      response = get_tenant_async(tenant_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprectaed] Get tenant
    #
    # Please use the Provider API instead.
    # Get the configuration for the specified tenant.
    #
    # @param tenant_id [String] The tenant identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_tenant_with_http_info(tenant_id, custom_headers:nil)
      get_tenant_async(tenant_id, custom_headers:custom_headers).value!
    end

    #
    # [Deprectaed] Get tenant
    #
    # Please use the Provider API instead.
    # Get the configuration for the specified tenant.
    #
    # @param tenant_id [String] The tenant identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_tenant_async(tenant_id, custom_headers:nil)
      fail ArgumentError, 'tenant_id is nil' if tenant_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'tenants/{tenantId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'tenantId' => tenant_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::TenantContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] Delete tenant
    #
    # Please use the Provider API instead.
    # Permanently remove the specified tenant, including their wallet, endpoint
    # registrations and all data.
    # All definitions, connections and credentials issued will be deleted.
    # This action cannot be reverted.
    #
    # @param tenant_id [String] The tenant identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_tenant(tenant_id, custom_headers:nil)
      response = delete_tenant_async(tenant_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # [Deprecated] Delete tenant
    #
    # Please use the Provider API instead.
    # Permanently remove the specified tenant, including their wallet, endpoint
    # registrations and all data.
    # All definitions, connections and credentials issued will be deleted.
    # This action cannot be reverted.
    #
    # @param tenant_id [String] The tenant identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_tenant_with_http_info(tenant_id, custom_headers:nil)
      delete_tenant_async(tenant_id, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Delete tenant
    #
    # Please use the Provider API instead.
    # Permanently remove the specified tenant, including their wallet, endpoint
    # registrations and all data.
    # All definitions, connections and credentials issued will be deleted.
    # This action cannot be reverted.
    #
    # @param tenant_id [String] The tenant identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_tenant_async(tenant_id, custom_headers:nil)
      fail ArgumentError, 'tenant_id is nil' if tenant_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'tenants/{tenantId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'tenantId' => tenant_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # [Deprecated] Get issuer status for current tenant
    #
    # Please use the Provider API instead.
    # If the tenant is configured with Dedicated endorsement, this action will
    # check if the issuer DID has the required ENDORSER role on the configured
    # ledger network.
    # Additionally, check the acceptance of the transaction author agreement and
    # return the text and version if acceptance is required.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [IssuerStatusContract] operation results.
    #
    def get_issuer_status(custom_headers:nil)
      response = get_issuer_status_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] Get issuer status for current tenant
    #
    # Please use the Provider API instead.
    # If the tenant is configured with Dedicated endorsement, this action will
    # check if the issuer DID has the required ENDORSER role on the configured
    # ledger network.
    # Additionally, check the acceptance of the transaction author agreement and
    # return the text and version if acceptance is required.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_issuer_status_with_http_info(custom_headers:nil)
      get_issuer_status_async(custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Get issuer status for current tenant
    #
    # Please use the Provider API instead.
    # If the tenant is configured with Dedicated endorsement, this action will
    # check if the issuer DID has the required ENDORSER role on the configured
    # ledger network.
    # Additionally, check the acceptance of the transaction author agreement and
    # return the text and version if acceptance is required.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_issuer_status_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'tenants/issuerStatus'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::IssuerStatusContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Send verification to connection from policy
    #
    # Send a verification to the specified connection using an existing policy.
    #
    # @param connection_id [String] The connection identifier
    # @param policy_id [String] The policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationContract] operation results.
    #
    def send_verification_from_policy(connection_id, policy_id, custom_headers:nil)
      response = send_verification_from_policy_async(connection_id, policy_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Send verification to connection from policy
    #
    # Send a verification to the specified connection using an existing policy.
    #
    # @param connection_id [String] The connection identifier
    # @param policy_id [String] The policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def send_verification_from_policy_with_http_info(connection_id, policy_id, custom_headers:nil)
      send_verification_from_policy_async(connection_id, policy_id, custom_headers:custom_headers).value!
    end

    #
    # Send verification to connection from policy
    #
    # Send a verification to the specified connection using an existing policy.
    #
    # @param connection_id [String] The connection identifier
    # @param policy_id [String] The policy identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def send_verification_from_policy_async(connection_id, policy_id, custom_headers:nil)
      fail ArgumentError, 'connection_id is nil' if connection_id.nil?
      fail ArgumentError, 'policy_id is nil' if policy_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verifications/policy/{policyId}/connections/{connectionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'connectionId' => connection_id,'policyId' => policy_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Send verification to connection from parameters
    #
    # Send a verification request to the specified connection from a set of
    # parameters.
    #
    # @param connection_id [String] The connection identifier
    # @param body [VerificationPolicyParameters] The policy parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationContract] operation results.
    #
    def send_verification_from_parameters(connection_id, body, custom_headers:nil)
      response = send_verification_from_parameters_async(connection_id, body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Send verification to connection from parameters
    #
    # Send a verification request to the specified connection from a set of
    # parameters.
    #
    # @param connection_id [String] The connection identifier
    # @param body [VerificationPolicyParameters] The policy parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def send_verification_from_parameters_with_http_info(connection_id, body, custom_headers:nil)
      send_verification_from_parameters_async(connection_id, body, custom_headers:custom_headers).value!
    end

    #
    # Send verification to connection from parameters
    #
    # Send a verification request to the specified connection from a set of
    # parameters.
    #
    # @param connection_id [String] The connection identifier
    # @param body [VerificationPolicyParameters] The policy parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def send_verification_from_parameters_async(connection_id, body, custom_headers:nil)
      fail ArgumentError, 'connection_id is nil' if connection_id.nil?
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::VerificationPolicyParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'verifications/policy/connections/{connectionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'connectionId' => connection_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Send verification from policy
    #
    # Create a verification from the specified policy and send it to the specified
    # connection.
    #
    # @param connection_id [String] The connection identifier
    # @param policy_id [String] The verification policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationContract] operation results.
    #
    def send_verification_from_proposal(connection_id, policy_id, custom_headers:nil)
      response = send_verification_from_proposal_async(connection_id, policy_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Send verification from policy
    #
    # Create a verification from the specified policy and send it to the specified
    # connection.
    #
    # @param connection_id [String] The connection identifier
    # @param policy_id [String] The verification policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def send_verification_from_proposal_with_http_info(connection_id, policy_id, custom_headers:nil)
      send_verification_from_proposal_async(connection_id, policy_id, custom_headers:custom_headers).value!
    end

    #
    # Send verification from policy
    #
    # Create a verification from the specified policy and send it to the specified
    # connection.
    #
    # @param connection_id [String] The connection identifier
    # @param policy_id [String] The verification policy identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def send_verification_from_proposal_async(connection_id, policy_id, custom_headers:nil)
      fail ArgumentError, 'connection_id is nil' if connection_id.nil?
      fail ArgumentError, 'policy_id is nil' if policy_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verifications/proposal/{policyId}/connections/{connectionId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'connectionId' => connection_id,'policyId' => policy_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create connectionless verification from policy
    #
    # Create a connectionless verification from the specified policy.
    # Connectionless transport uses URLs that can be shared with the user over any
    # existing transport (email, SMS, web).
    #
    # @param policy_id [String] The policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationContract] operation results.
    #
    def create_verification_from_policy(policy_id, custom_headers:nil)
      response = create_verification_from_policy_async(policy_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create connectionless verification from policy
    #
    # Create a connectionless verification from the specified policy.
    # Connectionless transport uses URLs that can be shared with the user over any
    # existing transport (email, SMS, web).
    #
    # @param policy_id [String] The policy identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_verification_from_policy_with_http_info(policy_id, custom_headers:nil)
      create_verification_from_policy_async(policy_id, custom_headers:custom_headers).value!
    end

    #
    # Create connectionless verification from policy
    #
    # Create a connectionless verification from the specified policy.
    # Connectionless transport uses URLs that can be shared with the user over any
    # existing transport (email, SMS, web).
    #
    # @param policy_id [String] The policy identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_verification_from_policy_async(policy_id, custom_headers:nil)
      fail ArgumentError, 'policy_id is nil' if policy_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verifications/policy/{policyId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'policyId' => policy_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create connectionless verification from parameters
    #
    # Create verification from parameters.
    # Connectionless transport uses URLs that can be shared with the user over any
    # existing transport (email, SMS, web).
    #
    # @param body [VerificationPolicyParameters] The policy parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationContract] operation results.
    #
    def create_verification_from_parameters(body, custom_headers:nil)
      response = create_verification_from_parameters_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create connectionless verification from parameters
    #
    # Create verification from parameters.
    # Connectionless transport uses URLs that can be shared with the user over any
    # existing transport (email, SMS, web).
    #
    # @param body [VerificationPolicyParameters] The policy parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_verification_from_parameters_with_http_info(body, custom_headers:nil)
      create_verification_from_parameters_async(body, custom_headers:custom_headers).value!
    end

    #
    # Create connectionless verification from parameters
    #
    # Create verification from parameters.
    # Connectionless transport uses URLs that can be shared with the user over any
    # existing transport (email, SMS, web).
    #
    # @param body [VerificationPolicyParameters] The policy parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_verification_from_parameters_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::VerificationPolicyParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'verifications/policy'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List all verifications
    #
    # List all verifications.
    # Optionally filter by connection and/or definition.
    #
    # @param connection_id [String] The connection identifier
    # @param definition_id [String] The definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_verifications(connection_id:nil, definition_id:nil, custom_headers:nil)
      response = list_verifications_async(connection_id:connection_id, definition_id:definition_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all verifications
    #
    # List all verifications.
    # Optionally filter by connection and/or definition.
    #
    # @param connection_id [String] The connection identifier
    # @param definition_id [String] The definition identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_verifications_with_http_info(connection_id:nil, definition_id:nil, custom_headers:nil)
      list_verifications_async(connection_id:connection_id, definition_id:definition_id, custom_headers:custom_headers).value!
    end

    #
    # List all verifications
    #
    # List all verifications.
    # Optionally filter by connection and/or definition.
    #
    # @param connection_id [String] The connection identifier
    # @param definition_id [String] The definition identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_verifications_async(connection_id:nil, definition_id:nil, custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verifications'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'connectionId' => connection_id,'definitionId' => definition_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'VerificationContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'VerificationContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # [Deprecated] Create/send verification
    #
    # Please use SendVerification(policyId) or CreateVerification(policyId)
    # instead.
    # This endpoint can be used to send a verification definition to a connection,
    # which will create a verification ID to track the response from the
    # connection.
    # If the parameter {connectionId} is not specified, this endpoint will create a
    # connectionless verification. A URL will be generated that can be shared with
    # anonymous user.
    #
    # @param body [VerificationParameters] The verification parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationContract] operation results.
    #
    def create_verification(body, custom_headers:nil)
      response = create_verification_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] Create/send verification
    #
    # Please use SendVerification(policyId) or CreateVerification(policyId)
    # instead.
    # This endpoint can be used to send a verification definition to a connection,
    # which will create a verification ID to track the response from the
    # connection.
    # If the parameter {connectionId} is not specified, this endpoint will create a
    # connectionless verification. A URL will be generated that can be shared with
    # anonymous user.
    #
    # @param body [VerificationParameters] The verification parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_verification_with_http_info(body, custom_headers:nil)
      create_verification_async(body, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Create/send verification
    #
    # Please use SendVerification(policyId) or CreateVerification(policyId)
    # instead.
    # This endpoint can be used to send a verification definition to a connection,
    # which will create a verification ID to track the response from the
    # connection.
    # If the parameter {connectionId} is not specified, this endpoint will create a
    # connectionless verification. A URL will be generated that can be shared with
    # anonymous user.
    #
    # @param body [VerificationParameters] The verification parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_verification_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::VerificationParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'verifications'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get verification
    #
    # Get the specified verification.
    #
    # @param verification_id [String] The verification identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationContract] operation results.
    #
    def get_verification(verification_id, custom_headers:nil)
      response = get_verification_async(verification_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get verification
    #
    # Get the specified verification.
    #
    # @param verification_id [String] The verification identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_verification_with_http_info(verification_id, custom_headers:nil)
      get_verification_async(verification_id, custom_headers:custom_headers).value!
    end

    #
    # Get verification
    #
    # Get the specified verification.
    #
    # @param verification_id [String] The verification identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_verification_async(verification_id, custom_headers:nil)
      fail ArgumentError, 'verification_id is nil' if verification_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verifications/{verificationId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'verificationId' => verification_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Delete verification
    #
    # Delete the specified verification.
    #
    # @param verification_id [String] The verification identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_verification(verification_id, custom_headers:nil)
      response = delete_verification_async(verification_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete verification
    #
    # Delete the specified verification.
    #
    # @param verification_id [String] The verification identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_verification_with_http_info(verification_id, custom_headers:nil)
      delete_verification_async(verification_id, custom_headers:custom_headers).value!
    end

    #
    # Delete verification
    #
    # Delete the specified verification.
    #
    # @param verification_id [String] The verification identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_verification_async(verification_id, custom_headers:nil)
      fail ArgumentError, 'verification_id is nil' if verification_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verifications/{verificationId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'verificationId' => verification_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # [Deprecated] Verify verification
    #
    # This action is now obsolete. Verifications are automatically verified when
    # they are received.
    # Execute verification on this record. This is an expensive action and is
    # executed by verifying the proof against the ledger data.
    #
    # @param verification_id [String] The verification identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerificationResult] operation results.
    #
    def verify_verification(verification_id, custom_headers:nil)
      response = verify_verification_async(verification_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # [Deprecated] Verify verification
    #
    # This action is now obsolete. Verifications are automatically verified when
    # they are received.
    # Execute verification on this record. This is an expensive action and is
    # executed by verifying the proof against the ledger data.
    #
    # @param verification_id [String] The verification identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def verify_verification_with_http_info(verification_id, custom_headers:nil)
      verify_verification_async(verification_id, custom_headers:custom_headers).value!
    end

    #
    # [Deprecated] Verify verification
    #
    # This action is now obsolete. Verifications are automatically verified when
    # they are received.
    # Execute verification on this record. This is an expensive action and is
    # executed by verifying the proof against the ledger data.
    #
    # @param verification_id [String] The verification identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def verify_verification_async(verification_id, custom_headers:nil)
      fail ArgumentError, 'verification_id is nil' if verification_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'verifications/{verificationId}/verify'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'verificationId' => verification_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::VerificationResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List all webhooks
    #
    # List all webhooks registered with the authenticated organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_webhooks(custom_headers:nil)
      response = list_webhooks_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all webhooks
    #
    # List all webhooks registered with the authenticated organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_webhooks_with_http_info(custom_headers:nil)
      list_webhooks_async(custom_headers:custom_headers).value!
    end

    #
    # List all webhooks
    #
    # List all webhooks registered with the authenticated organization.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_webhooks_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'webhooks'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'WebhookContractElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'WebhookContract'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Create webhook
    #
    # Register a webhook with the authenticated organization.
    #
    # @param body [WebhookParameters] The webhook parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [WebhookContract] operation results.
    #
    def create_webhook(body, custom_headers:nil)
      response = create_webhook_async(body, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Create webhook
    #
    # Register a webhook with the authenticated organization.
    #
    # @param body [WebhookParameters] The webhook parameters
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_webhook_with_http_info(body, custom_headers:nil)
      create_webhook_async(body, custom_headers:custom_headers).value!
    end

    #
    # Create webhook
    #
    # Register a webhook with the authenticated organization.
    #
    # @param body [WebhookParameters] The webhook parameters
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_webhook_async(body, custom_headers:nil)
      fail ArgumentError, 'body is nil' if body.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Credentials::Models::WebhookParameters.mapper()
      request_content = self.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'webhooks'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Credentials::Models::WebhookContract.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Remove webhook
    #
    # Remove a registered webhook from the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def remove_webhook(webhook_id, custom_headers:nil)
      response = remove_webhook_async(webhook_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Remove webhook
    #
    # Remove a registered webhook from the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def remove_webhook_with_http_info(webhook_id, custom_headers:nil)
      remove_webhook_async(webhook_id, custom_headers:custom_headers).value!
    end

    #
    # Remove webhook
    #
    # Remove a registered webhook from the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def remove_webhook_async(webhook_id, custom_headers:nil)
      fail ArgumentError, 'webhook_id is nil' if webhook_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'webhooks/{webhookId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'webhookId' => webhook_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Enable webhook
    #
    # Enable a registered webhook for the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def enable_webhook(webhook_id, custom_headers:nil)
      response = enable_webhook_async(webhook_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Enable webhook
    #
    # Enable a registered webhook for the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def enable_webhook_with_http_info(webhook_id, custom_headers:nil)
      enable_webhook_async(webhook_id, custom_headers:custom_headers).value!
    end

    #
    # Enable webhook
    #
    # Enable a registered webhook for the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def enable_webhook_async(webhook_id, custom_headers:nil)
      fail ArgumentError, 'webhook_id is nil' if webhook_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'webhooks/{webhookId}/enable'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'webhookId' => webhook_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Disable webhook
    #
    # Enable a registered webhook for the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def disable_webhook(webhook_id, custom_headers:nil)
      response = disable_webhook_async(webhook_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Disable webhook
    #
    # Enable a registered webhook for the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def disable_webhook_with_http_info(webhook_id, custom_headers:nil)
      disable_webhook_async(webhook_id, custom_headers:custom_headers).value!
    end

    #
    # Disable webhook
    #
    # Enable a registered webhook for the authenticated organization.
    #
    # @param webhook_id [String] The webhook identifier
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def disable_webhook_async(webhook_id, custom_headers:nil)
      fail ArgumentError, 'webhook_id is nil' if webhook_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'webhooks/{webhookId}/disable'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'webhookId' => webhook_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Health check
    #
    # Check the health of the API.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def health(custom_headers:nil)
      response = health_async(custom_headers:custom_headers).value!
      nil
    end

    #
    # Health check
    #
    # Check the health of the API.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def health_with_http_info(custom_headers:nil)
      health_async(custom_headers:custom_headers).value!
    end

    #
    # Health check
    #
    # Check the health of the API.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def health_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'health'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end


    private
    #
    # Adds telemetry information.
    #
    def add_telemetry
        sdk_information = 'credentials'
        sdk_information = "#{sdk_information}/1.1.4000"
        add_user_agent_information(sdk_information)
    end
  end
end
